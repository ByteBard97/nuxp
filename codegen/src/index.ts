/**
 * NUXP Code Generator - Main Entry Point
 *
 * This tool parses Adobe Illustrator SDK headers using tree-sitter and generates:
 * 1. C++ wrapper code with HTTP endpoints for each SDK suite function
 * 2. TypeScript client code for calling the C++ plugin from Tauri frontend
 *
 * Usage:
 *   npm run generate -- [options]
 *
 * Options:
 *   -s, --sdk <path>       Path to SDK headers (default: ../plugin/sdk)
 *   -o, --output <path>    Output directory (default: ./output)
 *   --suites <names>       Comma-separated list of suites to generate
 *   --cpp-only             Only generate C++ code
 *   --ts-only              Only generate TypeScript code
 *   -v, --verbose          Enable verbose logging
 */

import { Command } from 'commander';
import { SuiteParser } from './parser/SuiteParser';
import { CppGenerator } from './generator/CppGenerator';
import { TypeScriptGenerator } from './generator/TypeScriptGenerator';
import { SSEGenerator } from './generator/SSEGenerator';
import { CustomRouteGenerator } from './generator/CustomRouteGenerator';
import * as fs from 'fs-extra';
import * as path from 'path';
import * as glob from 'glob';
import winston from 'winston';

/**
 * Whitelist of suites to generate wrappers for.
 * These are suites that have been validated to work with the code generator.
 * Suites with complex parameter types (arrays, triple pointers, callbacks)
 * require manual implementation or generator improvements.
 */
const ALLOWED_SUITES: Set<string> = new Set([
    // Core art manipulation - basic functions only
    'AIArtSuite',
    'AIArtSetSuite',
    'AIGroupSuite',

    // Document and layer management
    'AIDocumentSuite',
    'AILayerSuite',
    'AILayerListSuite',
    'AIArtboardSuite',

    // Transform and geometry
    'AIRealMathSuite',
    'AITransformArtSuite',

    // Application context
    'AIAppContextSuite',

    // User interaction
    'AIUserSuite',

    // Undo management
    'AIUndoSuite',

    // Memory and dictionaries (Flora requirements)
    'AIMdMemorySuite',
    'AIDictionarySuite',
    'AIEntrySuite',

    // Plugin infrastructure
    'AINotifierSuite',
    'AITimerSuite',

    // Tools (Flora requirement)
    'AIToolSuite',

    // Blend styles (Flora requirement)
    'AIBlendStyleSuite',
    'AIMaskSuite',

    // Document view control (zoom, scroll, screen mode)
    'AIDocumentViewSuite',

    // Note: These suites were removed due to generator limitations:
    // - AIPathSuite: array parameters (AIPathSegment[])
    // - AIMatchingArtSuite: triple-pointer outputs (AIArtHandle***)
    // - AIColorSuite, AIPathStyleSuite, AIGradientSuite, AIPatternSuite: complex struct types
    // - AIDocumentListSuite: AINewDocumentPreset with explicit constructor
    // - AIRasterSuite: complex bitmap parameters
    // - AISwatchListSuite: array parameters
    // - AIPluginSuite: callback function pointers
]);

/**
 * Suites that are explicitly blocked even if in ALLOWED_SUITES.
 * Used for suites that cause ATE header conflicts or other issues.
 */
const BLOCKED_SUITES: Set<string> = new Set([
    // ATE (Adobe Text Engine) related suites - cause typedef conflicts
    'AIATECurrentTextFeaturesSuite',
    'AIATEPaintSuite',
    'AIATETextUtilSuite',
    'AIFontSuite',          // Includes ATE headers
    'AIMEFontSuite',        // Includes ATE headers
    'AILegacyTextConversionSuite',
    'AITextFrameSuite',
    'AITextFrameHitSuite',
    'AITextFrameMESuite',
]);

/**
 * Functions that are explicitly blocked from generation.
 * Generated by: npx ts-node scripts/analyze-edge-cases.ts
 *
 * Reasons for blocking:
 * - non-AIErr return type (void, AIBoolean, etc.)
 * - void/void* parameters (callbacks, user data)
 * - char** outputs (SDK-managed strings)
 * - complex struct types (AIColor, AIGradient, etc.)
 * - unmapped types (enums, complex structs, SPPluginRef)
 * - array parameters
 * - conditionally compiled (ILLUSTRATOR_MINIMAL)
 * - triple-pointer outputs (AIArtHandle***)
 */
const BLOCKED_FUNCTIONS: Set<string> = new Set([
    // Conditionally compiled (ILLUSTRATOR_MINIMAL)
    'CloneWithUniqueUUID',
    'GetRulerOriginAbsolute',
    'SetRulerOriginAbsolute',

    // Triple-pointer outputs (AIMatchingArtSuite)
    'GetSelectedArt',
    'GetSelectedArtFromLayers',
    'GetSelectedArtFromLayerList',
    'GetMatchingArt',
    'GetArtForCurrentPathStyle',
    'GetMatchingArtFromLayerList',
    'GetMatchingArtFromArt',

    // AIAppContextSuite - complex types, void* params
    'DoesAppContextExist',
    'MacGetAppQDGlobal',
    'ResumeAppContext',
    'SuspendAppContext',

    // AIArtSuite - complex types (XMP, dictionary, etc. - NOT return type issues)
    'ArtsHaveEqualPaths', // Complex comparison
    'CancelKeyArt', // void return but special semantics
    'DeleteNote',
    'GetArtXMP', // XMP complex type
    'GetDictionary', // Dictionary complex type
    'GetGlobalTimeStamp',
    'ObjectsAreEquivalent', // Complex comparison
    // Note: These AIBoolean-returning functions are now supported via code generator:
    // 'ArtHasFill', 'ArtHasStroke', 'HasDictionary', 'HasNote',
    // 'IsArtClipping', 'IsArtStyledArt', 'IsDictionaryEmpty', 'IsPixelPerfect', 'ValidArt'

    // AIArtboardSuite - complex types (AIColor)
    'GetColor',
    'SetColor',

    // AIBlendStyleSuite - previously blocked non-standard return types, now supported:
    // GetBlendingMode (returns AIBlendingMode/int32_t) and GetOpacity (returns AIReal/double)
    // are now handled via Primitive return classification in CppGenerator.
    // Note: These AIBoolean-returning functions are also supported via code generator:
    // 'ContainsNonIsolatedBlending', 'GetAlphaIsShape', 'GetDocumentIsolated',
    // 'GetDocumentKnockout', 'GetInheritedKnockout', 'GetIsolated', 'GetKnockout'

    // AIDictionarySuite - non-AIErr returns and const char** outputs
    'AddRef',
    'Get',
    'GetBinaryEntry',
    'GetStringEntry',  // const char** output parameter misclassified as input
    'IsKnown',
    'Key',
    'Release',
    'SetBinaryEntry',
    'Size',

    // AIDocumentSuite - complex types, non-AIErr returns, const char** outputs
    'GetAIVersion',
    // 'GetDictionary', // already added above
    'GetDocumentAssetMgmtInfo',
    'GetDocumentPixelPerfectStatus',
    'GetDocumentProfiles',
    'GetDocumentURL',   // const char** output parameter misclassified as input
    'GetDocumentXAP',   // const char** output parameter misclassified as input
    'GetEffectiveScaleFactor',
    'GetNonRecordedDictionary',
    'GetNonRecordedDictionaryForDocument',
    'IsCloudAIDocument',
    'RedrawDocument',
    'SetDocumentProfiles',
    'SyncDocument',

    // AIEntrySuite - non-AIErr returns, complex types, const char** outputs
    // 'AddRef', // already added
    'AsString', // const char** output parameter misclassified
    'ToString', // const char** output parameter misclassified
    'Equiv',
    'FromArray',
    'FromArtStyle',
    'FromBinary',
    'FromBoolean',
    'FromBrushPattern',
    'FromCustomColor',
    'FromDict',
    'FromFillStyle',
    'FromGradient',
    'FromInteger',
    'FromPattern',
    'FromPluginObject',
    'FromReal',
    'FromRealMatrix',
    'FromRealPoint',
    'FromSVGFilterHandle',
    'FromString',
    'FromStrokeStyle',
    'FromSymbolPattern',
    'FromUID',
    'FromUIDREF',
    'FromUnicodeString',
    'FromXMLNode',
    'GetType',
    // 'Release', // already added
    'ToBinary',
    'ToBrushPattern',
    'ToGradient',
    'ToPattern',
    'ToSymbolPattern',

    // AILayerListSuite - void* params, char** outputs
    'GetDisplayMode',
    'GetEditabilityMode',
    'Pop',
    'Push',

    // AIMaskSuite - non-AIErr returns
    // 'AddRef', // already added
    // GetArt (returns AIArtHandle) now supported via Handle return classification
    // 'Release', // already added
    // Note: These AIBoolean-returning functions are now supported via code generator:
    // 'GetClipping', 'GetDisabled', 'GetInverted', 'GetLinked', 'IsEditingArt'

    // AIDocumentViewSuite - const pointer-to-struct params misclassified as by-value
    'ViewPointToArtworkPoint',
    'ViewPointToArtworkPointUnrotated',
    'ViewRectToArtworkRect',
    'ViewRectToArtworkRectUnrotated',
    // AIDocumentViewSuite - ai::ColorSpace requires unlinked symbols
    'GetNthOPPPlate',
    'GetOPPPlateState',
    'SetOPPPlateState',

    // AIMdMemorySuite - void* params
    'MdMemoryLock',

    // AINotifierSuite - void* params, const char** outputs
    'GetNotifierName', // const char** output parameter misclassified
    'GetNotifierType', // const char** output parameter misclassified
    'Notify',

    // AIRealMathSuite - all return void or non-AIErr
    'AIDoubleRectUnion',
    'AIFixedMatrixToAIRealMatrix',
    'AIFixedPointToAIRealPoint',
    'AIFixedRectToAIRealRect',
    'AIFixedToAIReal',
    'AIFloatMatrixToAIRealMatrix',
    'AIFloatPointToAIRealPoint',
    'AIRealATan',
    'AIRealAdd',
    'AIRealCos',
    'AIRealDiv',
    'AIRealInterpolate',
    'AIRealIsNAN',
    'AIRealLength',
    'AIRealMatrixConcat',
    'AIRealMatrixConcatRotate',
    'AIRealMatrixConcatScale',
    'AIRealMatrixConcatTranslate',
    'AIRealMatrixEqual',
    'AIRealMatrixGetRotate',
    'AIRealMatrixGetScale',
    'AIRealMatrixGetTranslate',
    'AIRealMatrixIdentity',
    'AIRealMatrixInvert',
    'AIRealMatrixSet',
    'AIRealMatrixSetIdentity',
    'AIRealMatrixSetRotate',
    'AIRealMatrixSetScale',
    'AIRealMatrixSetTranslate',
    'AIRealMatrixSingular',
    'AIRealMatrixToAIFixedMatrix',
    'AIRealMatrixXformPoint',
    'AIRealMatrixXformRect',
    'AIRealMul',
    'AIRealMulAdd',
    'AIRealMultiple',
    'AIRealPointAdd',
    'AIRealPointAngle',
    'AIRealPointClose',
    'AIRealPointEqual',
    'AIRealPointInAIRealRect',
    'AIRealPointInterpolate',
    'AIRealPointLength',
    'AIRealPointLengthAngle',
    'AIRealPointSubtract',
    'AIRealPointToAIFixedPoint',
    'AIRealPointUnion',
    'AIRealRatio',
    'AIRealRectAlign',
    'AIRealRectEmpty',
    'AIRealRectEqual',
    'AIRealRectInAIRealRect',
    'AIRealRectInset',
    'AIRealRectIntersect',
    'AIRealRectOffset',
    'AIRealRectOverlap',
    'AIRealRectSet',
    'AIRealRectToAIFixedRect',
    'AIRealRectUnion',
    'AIRealSin',
    'AIRealSqrt',
    'AIRealToAIFixed',
    'AlmostEqual',
    'DegreeToRadian',
    'EqualWithinTol',
    'IsAIRealUnknown',
    'RadianToDegree',
    'RestrictAngleToRange',
    'ShortRatio',

    // AITimerSuite - char** outputs are now supported via code generator
    // 'GetTimerName',

    // AIToolSuite - complex types, array params, void* params, const char** outputs
    'AddTool',  // AIAddToolData has explicit constructor
    'AddToolPrivate',  // AIAddToolDataPrivate has explicit constructor
    'GetAlternateSelectionToolName', // May have other issues beyond char**
    'GetCurrentToolName',  // const char** output parameter misclassified
    'GetCurrentEffectiveToolName',  // const char** output parameter misclassified
    'GetLastUsedSelectionTool', // void* params
    'GetToolIcons', // Array params
    'SetToolInfoVarValues', // void* params
    'SetToolInfoVars', // void* params
    // Note: These char**-output functions are now supported via code generator:
    // 'GetToolName', 'GetToolNameFromNumber', 'GetTimerName'

    // AIUndoSuite - void params
    'RevertAndForgetLastTransaction',
    'SetActionPaletteUndo',
    'UndoChanges',

    // AIUserSuite - non-AIErr returns, void params, callbacks, complex types
    'AIRealToString',
    'AppIdle',
    'Cancel',
    'ChooseFromOSColorPicker',
    'CloseProgress',
    'CopyOfName',
    'DisableProgressCancel',
    'ErrorAlert',
    'GetAppScaleFactor',
    'GetDateString',
    'GetDay',
    'GetDayOfWeek',
    'GetFileDialog',
    'GetFileDialogEx',
    'GetHour',
    'GetMinute',
    'GetMonth',
    'GetSecond',
    'GetTimeString',
    'GetYear',
    'GetArtToViewScaleFactor',
    'GetInputFromUser',
    'GetMaximumScaleFactorOnSystem',
    'IUAIRealToString',
    'IUAIRealToStringWithLocale',
    'IUAIRealToStringWithLocaleWithoutScale',
    'IUStringToAIReal',
    'IUStringUnitsToAIReal',
    'IUStringUnitsToAIRealWithoutScale',
    'MessageAlert',
    'MessageAlertEx',
    'NextName',
    'OKCancelAlert',
    'OKToAllocateMemory',
    'PutFileDialog',
    'QuestionAlert',
    'SetProgressText',
    'SetUpdateProgressCallback',
    'StringToAIReal',
    'UpdateProgress',
    'WarningAlert',
    'YesNoAlert',

    // AIBlendStyleSuite - enum params (AIBlendingMode, AIKnockout) not yet mapped to int
    // Note: AIDictionaryRef and AIArtStyleHandle are now fully supported.
    // The *BlendStyle* and *AllAttrs variants use enum types that need codegen enum mapping.
    'SetBlendingMode',
    'SetKnockout',
    'GetBlendStyleAttrs',
    'SetBlendStyleAttrs',
    'GetFocalFillBlendStyleAttrs',
    'SetFocalFillBlendStyleAttrs',
    'GetFocalStrokeBlendStyleAttrs',
    'SetFocalStrokeBlendStyleAttrs',
    'GetBlendStyleAllAttrs',
    'SetBlendStyleAllAttrs',
    'GetFocalBlendStyleAllAttrs',
    'SetFocalBlendStyleAllAttrs',
    'GetFocalFillBlendStyleAllAttrs',
    'SetFocalFillBlendStyleAllAttrs',

    // AIAppContextSuite - SPPluginRef, AIAppContextHandle, enum types
    'PushAppContext',
    'PopAppContext',
    'GetAppContextKind',
    'SetAppContextKind',

    // AINotifierSuite - SPPluginRef
    'AddNotifier',

    // AITimerSuite - SPPluginRef
    'AddTimer',

    // AILayerSuite - unmapped types (AIRGBColor struct, AIPaintOrder enum)
    'SetLayerColor',
    'InsertLayerAtPaintOrder',

    // AIGroupSuite - enum (AINormalizeCompoundPathAlgorithm)
    'NormalizeCompoundPath',

    // AIDocumentSuite - complex/enum types
    'SetCropStyle',
    'GetPrintRecord',
    'WriteDocumentWithOptions',
    'GetDocumentFileFormatParameters',
    'SetMiPrintRecord',
    'GetMiPrintRecord',
    'GetTextSelection',
    'SetDocumentSpotColorMode',

    // AIToolSuite - unmapped compound types
    'SetToolDocInkParams',

    // AIUserSuite - SPPluginRef, AIResourceManagerHandle
    'CreateCursorResourceMgr',
    'GetCursorID',
    'DisposeCursorResourceMgr',
    'SetCursorID',
]);

// Configure logger with colored output
const logger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
        winston.format.colorize(),
        winston.format.printf(({ level, message }) => {
            return `${level}: ${message}`;
        })
    ),
    transports: [new winston.transports.Console()]
});

interface ProgramOptions {
    sdk: string;
    output: string;
    suites: string;
    cppOnly: boolean;
    tsOnly: boolean;
    verbose: boolean;
}

/**
 * Validates that required paths exist
 */
async function validatePaths(sdkPath: string, configPath: string): Promise<void> {
    if (!await fs.pathExists(sdkPath)) {
        throw new Error(`SDK path does not exist: ${sdkPath}`);
    }

    if (!await fs.pathExists(configPath)) {
        throw new Error(`Config file does not exist: ${configPath}`);
    }
}

/**
 * Finds SDK header files matching the pattern AI*.h
 */
function findSdkHeaders(sdkPath: string): string[] {
    // Look for headers in the root of sdk/ and in sdk/actions/
    const patterns = [
        path.join(sdkPath, 'AI*.h'),
        path.join(sdkPath, 'actions', 'AI*.h')
    ];

    let allHeaders: string[] = [];
    for (const pattern of patterns) {
        const headers = glob.sync(pattern);
        allHeaders = allHeaders.concat(headers);
    }

    // Sort for consistent ordering
    return allHeaders.sort();
}

/**
 * Main entry point for the code generator
 */
async function main(): Promise<void> {
    const program = new Command();

    program
        .name('nuxp-codegen')
        .description('Generate C++ and TypeScript wrappers for Adobe Illustrator SDK')
        .version('1.0.0')
        .option('-s, --sdk <path>', 'Path to SDK headers', '../plugin/sdk')
        .option('-o, --output <path>', 'Output directory', './output')
        .option('--suites <names>', 'Comma-separated list of suites to generate (default: all)', '')
        .option('--cpp-only', 'Only generate C++ code', false)
        .option('--ts-only', 'Only generate TypeScript code', false)
        .option('-v, --verbose', 'Verbose output', false);

    program.parse();
    const options = program.opts<ProgramOptions>();

    // Enable verbose logging if requested
    if (options.verbose) {
        logger.level = 'debug';
    }

    logger.info('NUXP Code Generator');
    logger.info('==================');

    // Resolve paths relative to the src directory (where index.ts is located)
    const srcDir = __dirname;
    const codegenDir = path.dirname(srcDir);
    const sdkPath = path.resolve(codegenDir, options.sdk);
    const outputPath = path.resolve(codegenDir, options.output);
    const configPath = path.resolve(srcDir, 'config', 'type-map.json');

    logger.debug(`Source directory: ${srcDir}`);
    logger.debug(`SDK path: ${sdkPath}`);
    logger.debug(`Output path: ${outputPath}`);
    logger.debug(`Config path: ${configPath}`);

    // Validate paths
    try {
        await validatePaths(sdkPath, configPath);
    } catch (err) {
        logger.error((err as Error).message);
        process.exit(1);
    }

    // Ensure output directories exist
    const cppOutputDir = path.join(outputPath, 'cpp');
    const tsOutputDir = path.join(outputPath, 'typescript');
    const docsOutputDir = path.join(outputPath, 'docs');

    await fs.ensureDir(cppOutputDir);
    await fs.ensureDir(tsOutputDir);
    await fs.ensureDir(docsOutputDir);

    logger.debug(`C++ output: ${cppOutputDir}`);
    logger.debug(`TypeScript output: ${tsOutputDir}`);

    // Find SDK headers
    const headers = findSdkHeaders(sdkPath);

    if (headers.length === 0) {
        logger.error(`No SDK headers found at ${sdkPath}`);
        logger.error('Expected files matching pattern: AI*.h');
        process.exit(1);
    }

    logger.info(`Found ${headers.length} SDK headers`);

    // Initialize parser and generators
    const parser = new SuiteParser(configPath);
    const cppGen = new CppGenerator(configPath);
    const tsGen = new TypeScriptGenerator(configPath);

    // Parse suite filter if provided
    const suiteFilter = options.suites
        ? options.suites.split(',').map((s: string) => s.trim()).filter(Boolean)
        : null;

    if (suiteFilter) {
        logger.info(`Filtering suites: ${suiteFilter.join(', ')}`);
    }

    // Track statistics
    let totalSuites = 0;
    let totalFunctions = 0;
    let totalCppFiles = 0;
    let totalTsFiles = 0;
    const errors: { header: string; error: string }[] = [];
    const generatedSuiteNames: string[] = []; // Track generated suite names for CentralDispatcher

    // Process each header file
    for (const headerPath of headers) {
        const headerName = path.basename(headerPath);
        logger.debug(`Parsing ${headerName}...`);

        try {
            const suites = await parser.parseFile(headerPath);

            for (let suite of suites) {
                // Skip blocked suites (ATE conflicts, macro conflicts, etc.)
                if (BLOCKED_SUITES.has(suite.name)) {
                    logger.debug(`  Skipping ${suite.name} (blocked: ATE/macro conflict)`);
                    continue;
                }

                // Filter out blocked functions
                const originalCount = suite.functions.length;
                suite = {
                    ...suite,
                    functions: suite.functions.filter(f => !BLOCKED_FUNCTIONS.has(f.name))
                };
                if (suite.functions.length < originalCount) {
                    logger.debug(`  Filtered ${originalCount - suite.functions.length} blocked functions from ${suite.name}`);
                }

                // Skip if not in whitelist (unless explicit filter is provided)
                if (!suiteFilter && !ALLOWED_SUITES.has(suite.name)) {
                    logger.debug(`  Skipping ${suite.name} (not in allowed list)`);
                    continue;
                }

                // Skip if not in filter (when explicit filter is provided)
                if (suiteFilter && !suiteFilter.includes(suite.name)) {
                    logger.debug(`  Skipping ${suite.name} (not in filter)`);
                    continue;
                }

                // Skip suites with no functions
                if (suite.functions.length === 0) {
                    logger.debug(`  Skipping ${suite.name} (no functions)`);
                    continue;
                }

                logger.info(`Generating ${suite.name} (${suite.functions.length} functions)...`);

                // Generate C++ code
                if (!options.tsOnly) {
                    try {
                        const cppFiles = cppGen.generate(suite);
                        for (const file of cppFiles) {
                            const filePath = path.join(cppOutputDir, file.filename);
                            await fs.writeFile(filePath, file.content, 'utf-8');
                            logger.debug(`  Wrote ${file.filename}`);
                            totalCppFiles++;
                        }
                        // Track suite name for CentralDispatcher generation
                        generatedSuiteNames.push(suite.name);
                    } catch (err) {
                        logger.error(`  Error generating C++ for ${suite.name}: ${err}`);
                        errors.push({ header: headerName, error: `C++ generation: ${err}` });
                    }
                }

                // Generate TypeScript code
                if (!options.cppOnly) {
                    try {
                        const tsFile = tsGen.generate(suite);
                        const filePath = path.join(tsOutputDir, tsFile.filename);
                        await fs.writeFile(filePath, tsFile.content, 'utf-8');
                        logger.debug(`  Wrote ${tsFile.filename}`);
                        totalTsFiles++;
                    } catch (err) {
                        logger.error(`  Error generating TypeScript for ${suite.name}: ${err}`);
                        errors.push({ header: headerName, error: `TypeScript generation: ${err}` });
                    }
                }

                totalSuites++;
                totalFunctions += suite.functions.length;
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            logger.error(`Error processing ${headerName}: ${errorMessage}`);
            errors.push({ header: headerName, error: errorMessage });
        }
    }

    // Print summary
    logger.info('');
    logger.info('Generation Complete!');
    logger.info('====================');
    logger.info(`  Suites processed: ${totalSuites}`);
    logger.info(`  Functions found:  ${totalFunctions}`);

    if (!options.tsOnly) {
        logger.info(`  C++ files:        ${totalCppFiles}`);
    }
    if (!options.cppOnly) {
        logger.info(`  TypeScript files: ${totalTsFiles}`);
    }

    logger.info(`  Output directory: ${outputPath}`);

    if (errors.length > 0) {
        logger.warn('');
        logger.warn(`Errors encountered: ${errors.length}`);
        for (const { header, error } of errors) {
            logger.warn(`  ${header}: ${error}`);
        }
    }

    // Generate shared types file and index for TypeScript exports
    if (!options.cppOnly && totalTsFiles > 0) {
        const typesFile = tsGen.generateTypesFile();
        await fs.writeFile(path.join(tsOutputDir, typesFile.filename), typesFile.content, 'utf-8');
        logger.debug(`  Wrote ${typesFile.filename}`);
        await generateTypeScriptIndex(tsOutputDir);
    }

    // Generate CentralDispatcher.h for C++ routing (before CMake include so it's listed)
    if (!options.tsOnly && generatedSuiteNames.length > 0) {
        await generateCentralDispatcher(cppOutputDir, generatedSuiteNames);
        logger.debug('Generated CentralDispatcher.h');
    }

    // Generate SSE events if events.json exists
    const eventsConfigPath = path.resolve(srcDir, 'config', 'events.json');
    const hasEventsConfig = await fs.pathExists(eventsConfigPath);

    if (hasEventsConfig) {
        logger.info('Generating SSE events...');

        try {
            const sseGen = new SSEGenerator(eventsConfigPath);

            // Generate C++ Events.hpp
            if (!options.tsOnly) {
                const cppFile = sseGen.generateCpp();
                const cppPath = path.join(cppOutputDir, cppFile.filename);
                await fs.writeFile(cppPath, cppFile.content, 'utf-8');
                logger.debug(`  Wrote ${cppFile.filename}`);
            }

            // Generate TypeScript events.ts
            if (!options.cppOnly) {
                const tsFile = sseGen.generateTypeScript();
                const tsPath = path.join(tsOutputDir, tsFile.filename);
                await fs.writeFile(tsPath, tsFile.content, 'utf-8');
                logger.debug(`  Wrote ${tsFile.filename}`);
            }

            logger.info('SSE events generated successfully');
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            logger.error(`Error generating SSE events: ${errorMessage}`);
            errors.push({ header: 'events.json', error: errorMessage });
        }
    } else {
        logger.debug('No events.json found, skipping SSE generation');
    }

    // Generate custom routes if routes.json exists
    const routesConfigPath = path.resolve(srcDir, 'config', 'routes.json');
    const hasRoutesConfig = await fs.pathExists(routesConfigPath);

    if (hasRoutesConfig) {
        logger.info('Generating custom routes...');

        try {
            const routeGen = new CustomRouteGenerator(routesConfigPath);

            // Generate C++ CustomRouteRegistration.cpp
            if (!options.tsOnly) {
                const regFile = routeGen.generateCppRegistration();
                const regPath = path.join(cppOutputDir, regFile.filename);
                await fs.writeFile(regPath, regFile.content, 'utf-8');
                logger.debug(`  Wrote ${regFile.filename}`);

                const declFile = routeGen.generateCppDeclarations();
                const declPath = path.join(cppOutputDir, declFile.filename);
                await fs.writeFile(declPath, declFile.content, 'utf-8');
                logger.debug(`  Wrote ${declFile.filename}`);
            }

            // Generate TypeScript customRoutes.ts
            if (!options.cppOnly) {
                const tsFile = routeGen.generateTypeScript();
                const tsPath = path.join(tsOutputDir, tsFile.filename);
                await fs.writeFile(tsPath, tsFile.content, 'utf-8');
                logger.debug(`  Wrote ${tsFile.filename}`);
            }

            logger.info('Custom routes generated successfully');
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : String(err);
            logger.error(`Error generating custom routes: ${errorMessage}`);
            errors.push({ header: 'routes.json', error: errorMessage });
        }
    } else {
        logger.debug('No routes.json found, skipping custom route generation');
    }

    // Generate CMake include file for C++ sources (after CentralDispatcher so it's included)
    if (!options.tsOnly && totalCppFiles > 0) {
        await generateCMakeInclude(cppOutputDir);
    }
}

/**
 * Generates an index.ts file that re-exports all generated TypeScript modules.
 * Detects duplicate export names across files and emits explicit named
 * re-exports to avoid TS2308 conflicts.
 */
async function generateTypeScriptIndex(tsOutputDir: string): Promise<void> {
    const tsFiles = glob.sync(path.join(tsOutputDir, '*.ts'))
        .map(f => path.basename(f, '.ts'))
        .filter(b => b !== 'index')
        .sort();

    if (tsFiles.length === 0) return;

    // Collect exported names from each file
    const exportsByFile = new Map<string, string[]>();
    for (const basename of tsFiles) {
        const content = await fs.readFile(path.join(tsOutputDir, `${basename}.ts`), 'utf-8');
        const names: string[] = [];
        // Match: export interface Foo, export async function Foo, export function Foo,
        //        export type Foo, export const Foo, export class Foo
        const re = /^export\s+(?:async\s+)?(?:interface|function|type|const|class|enum)\s+(\w+)/gm;
        let m;
        while ((m = re.exec(content)) !== null) {
            names.push(m[1]);
        }
        exportsByFile.set(basename, names);
    }

    // Find names exported by multiple files
    const nameToFiles = new Map<string, string[]>();
    for (const [file, names] of exportsByFile) {
        for (const name of names) {
            const files = nameToFiles.get(name) || [];
            files.push(file);
            nameToFiles.set(name, files);
        }
    }
    const duplicateNames = new Set<string>();
    for (const [name, files] of nameToFiles) {
        if (files.length > 1) duplicateNames.add(name);
    }

    // Build export lines
    const lines: string[] = [];
    const emittedNames = new Set<string>();

    for (const basename of tsFiles) {
        const names = exportsByFile.get(basename) || [];
        const conflicting = names.filter(n => duplicateNames.has(n));

        if (conflicting.length === 0) {
            // No conflicts — safe to use export *
            lines.push(`export * from './${basename}';`);
        } else {
            // Some names conflict — use explicit named exports, skipping already-emitted names
            const safeNames = names.filter(n => !emittedNames.has(n));
            if (safeNames.length > 0) {
                lines.push(`export { ${safeNames.join(', ')} } from './${basename}';`);
            }
        }
        for (const n of names) emittedNames.add(n);
    }

    const indexContent = `/**
 * NUXP SDK Client - Auto-generated index
 * Re-exports all generated suite modules
 */

${lines.join('\n')}
`;
    await fs.writeFile(path.join(tsOutputDir, 'index.ts'), indexContent, 'utf-8');
    logger.debug('Generated TypeScript index.ts');
}

/**
 * Generates a CMake include file listing all generated C++ sources
 */
async function generateCMakeInclude(cppOutputDir: string): Promise<void> {
    const cppFiles = glob.sync(path.join(cppOutputDir, '*.cpp'));
    const hppFiles = glob.sync(path.join(cppOutputDir, '*.hpp'));
    const hFiles = glob.sync(path.join(cppOutputDir, '*.h'));

    const sources = cppFiles.map(f => path.basename(f));
    const headers = [...hppFiles, ...hFiles].map(f => path.basename(f));

    const cmakeContent = `# Auto-generated by NUXP Codegen - DO NOT EDIT
# Include this file in your CMakeLists.txt

set(GENERATED_SOURCES
${sources.map(s => `    \${CMAKE_CURRENT_LIST_DIR}/${s}`).join('\n')}
)

set(GENERATED_HEADERS
${headers.map(h => `    \${CMAKE_CURRENT_LIST_DIR}/${h}`).join('\n')}
)
`;
    await fs.writeFile(path.join(cppOutputDir, 'generated_sources.cmake'), cmakeContent, 'utf-8');
    logger.debug('Generated CMake include file');
}

/**
 * Generates CentralDispatcher.h that routes by suite name to suite-specific dispatchers
 */
async function generateCentralDispatcher(cppOutputDir: string, suiteNames: string[]): Promise<void> {
    // Sort suite names for consistent output
    const sortedSuites = [...suiteNames].sort();

    // Generate includes
    const includes = sortedSuites.map(name => `#include "Flora${name}Wrapper.h"`).join('\n');

    // Generate dispatch cases
    const dispatchCases: string[] = [];
    for (let i = 0; i < sortedSuites.length; i++) {
        const suite = sortedSuites[i];
        if (i === 0) {
            dispatchCases.push(`    if (suite == "${suite}") {`);
        } else {
            dispatchCases.push(`    } else if (suite == "${suite}") {`);
        }
        dispatchCases.push(`        return Flora::${suite}::Dispatch(method, params);`);
    }
    if (sortedSuites.length > 0) {
        dispatchCases.push(`    }`);
    }

    const content = `#pragma once
// Auto-generated by NUXP Codegen - DO NOT EDIT
// Central dispatcher that routes by suite name to suite-specific dispatchers

#include <nlohmann/json.hpp>
#include <string>
#include <stdexcept>

${includes}

namespace Flora {

/**
 * Central dispatch function that routes requests to suite-specific dispatchers
 * @param suite The suite name (e.g., "AIArtSuite")
 * @param method The method name within the suite (e.g., "NewArt")
 * @param params The JSON parameters to pass to the method
 * @returns The JSON result from the method call
 * @throws std::runtime_error if suite or method is not found
 */
inline nlohmann::json Dispatch(const std::string& suite, const std::string& method, const nlohmann::json& params) {
${dispatchCases.join('\n')}
    throw std::runtime_error("Unknown suite: " + suite);
}

} // namespace Flora
`;

    await fs.writeFile(path.join(cppOutputDir, 'CentralDispatcher.h'), content, 'utf-8');
}

// Run the main function
main().catch(err => {
    console.error('Fatal error:', err);
    process.exit(1);
});
