// Auto-generated by NUXP Codegen - DO NOT EDIT
#include "CustomRouteHandlers.h"
#include "HttpServer.hpp"
#include <string>
#include <vector>

void RegisterCustomRoutes() {
    using namespace NUXP;

    // GET /api/selection - Get all currently selected art objects as handle IDs. Wraps AIMatchingArtSuite::GetSelectedArt (AIArtHandle*** output). Handler must iterate, register each handle, and free with MdMemoryDisposeHandle.
    HttpServer::Get("/api/selection", [](const std::string&) {
        return HandleGetSelection();
    });

    // POST /api/selection/match - Get art objects matching type and attribute filters. Wraps AIMatchingArtSuite::GetMatchingArt with AIMatchingArtSpec.
    HttpServer::Post("/api/selection/match", [](const std::string& body) {
        return HandleGetMatchingArt(body);
    });

    // GET /api/art/{id}/style - Get fill and stroke style of an art object. Wraps AIPathStyleSuite::GetPathStyle. Color is a tagged union — check color.kind to determine which fields are present (gray&#x2F;rgb&#x2F;cmyk&#x2F;pattern&#x2F;gradient&#x2F;custom&#x2F;none).
    HttpServer::GetWithPattern(
        R"(/api/art/([a-zA-Z0-9_.-]+)/style)",
        [](const std::string& body, const std::vector<std::string>& params) {
            if (params.empty()) {
                return std::string("{\"error\":\"missing_id\"}");
            }
            return HandleGetPathStyle(params[0]);
        });

    // POST /api/art/{id}/style - Set fill and stroke style for an art object. Wraps AIPathStyleSuite::SetPathStyle. All fields optional — only provided fields are changed. For color, include kind + variant fields.
    HttpServer::PostWithPattern(
        R"(/api/art/([a-zA-Z0-9_.-]+)/style)",
        [](const std::string& body, const std::vector<std::string>& params) {
            if (params.empty()) {
                return std::string("{\"error\":\"missing_id\"}");
            }
            return HandleSetPathStyle(params[0], body);
        });

    // GET /api/art/{id}/segments - Get all path segments for a path art object. Wraps AIPathSuite::GetPathSegmentCount + GetPathSegments. Each segment has anchor (p), incoming handle (in), outgoing handle (out), and corner flag.
    HttpServer::GetWithPattern(
        R"(/api/art/([a-zA-Z0-9_.-]+)/segments)",
        [](const std::string& body, const std::vector<std::string>& params) {
            if (params.empty()) {
                return std::string("{\"error\":\"missing_id\"}");
            }
            return HandleGetPathSegments(params[0]);
        });

    // POST /api/art/{id}/segments - Set path segments for a path art object. Wraps AIPathSuite::SetPathSegments. Replaces segments starting at given index.
    HttpServer::PostWithPattern(
        R"(/api/art/([a-zA-Z0-9_.-]+)/segments)",
        [](const std::string& body, const std::vector<std::string>& params) {
            if (params.empty()) {
                return std::string("{\"error\":\"missing_id\"}");
            }
            return HandleSetPathSegments(params[0], body);
        });

    // POST /api/artboard/check-bounds - Check if a rectangle fits within the active artboard bounds and compute clamped coordinates. Uses AIArtboardSuite to get artboard geometry and GeometryUtils for intersection.
    HttpServer::Post("/api/artboard/check-bounds", [](const std::string& body) {
        return HandleCheckBounds(body);
    });

    // POST /api/selection/deselect-all - Deselect all currently selected art objects. Wraps AIMatchingArtSuite iteration + AIArtSuite::SetArtUserAttr to clear kArtSelected flag.
    HttpServer::Post("/api/selection/deselect-all", [](const std::string&) {
        return HandleDeselectAll();
    });

    // POST /api/selection/select - Select art objects by their handle IDs. Resolves handles from HandleManager::art, then sets kArtSelected attribute via AIArtSuite::SetArtUserAttr.
    HttpServer::Post("/api/selection/select", [](const std::string& body) {
        return HandleSelectByHandles(body);
    });

    // GET /api/query/text-frames - Query all text frame art objects in the current document. Wraps AIMatchingArtSuite::GetMatchingArt with type&#x3D;kTextFrameArt. Returns handles and basic properties for each frame.
    HttpServer::Get("/api/query/text-frames", [](const std::string&) {
        return HandleQueryTextFrames();
    });

    // GET /api/query/layers - Query all layers in the current document with their properties. Wraps AILayerSuite iteration (CountLayers + GetNthLayer + layer property getters).
    HttpServer::Get("/api/query/layers", [](const std::string&) {
        return HandleQueryLayers();
    });

    // POST /api/query/find - Find art objects by name. Iterates document art tree using AIArtSuite::GetArtFirstChild&#x2F;GetArtSibling, checking GetArtName against the query string.
    HttpServer::Post("/api/query/find", [](const std::string& body) {
        return HandleFindArtByName(body);
    });

    // GET /api/art/{id}/area - Calculate the area of a path art object using the shoelace formula on linearized bezier segments. Uses GeometryUtils::CalculatePathArea.
    HttpServer::GetWithPattern(
        R"(/api/art/([a-zA-Z0-9_.-]+)/area)",
        [](const std::string& body, const std::vector<std::string>& params) {
            if (params.empty()) {
                return std::string("{\"error\":\"missing_id\"}");
            }
            return HandleCalculatePathArea(params[0]);
        });

    // POST /api/text/create - Create a new point text frame. Uses AITextFrameSuite::NewPointText via forward-declared vtable (avoids ATE header conflicts).
    HttpServer::Post("/api/text/create", [](const std::string& body) {
        return HandleCreateTextFrame(body);
    });

    // GET /api/text/{id}/content - Get text content from a text frame via ATE TextRangeRef.
    HttpServer::GetWithPattern(
        R"(/api/text/([a-zA-Z0-9_.-]+)/content)",
        [](const std::string& body, const std::vector<std::string>& params) {
            if (params.empty()) {
                return std::string("{\"error\":\"missing_id\"}");
            }
            return HandleGetTextContent(params[0]);
        });

    // POST /api/text/{id}/content - Set text content on a text frame. Replaces all existing text.
    HttpServer::PostWithPattern(
        R"(/api/text/([a-zA-Z0-9_.-]+)/content)",
        [](const std::string& body, const std::vector<std::string>& params) {
            if (params.empty()) {
                return std::string("{\"error\":\"missing_id\"}");
            }
            return HandleSetTextContent(params[0], body);
        });

    // GET /api/xmp - Get full document XMP metadata as an XML packet string. Uses AIDocumentSuite to retrieve the XMP metadata.
    HttpServer::Get("/api/xmp", [](const std::string&) {
        return HandleGetDocumentXmp();
    });

    // POST /api/xmp - Set full document XMP metadata from an XML packet string. Pass xmp as null to clear metadata.
    HttpServer::Post("/api/xmp", [](const std::string& body) {
        return HandleSetDocumentXmp(body);
    });

    // GET /api/xmp/status - Check XMP availability and capabilities. Reports whether document-level and property-level XMP access is available.
    HttpServer::Get("/api/xmp/status", [](const std::string&) {
        return HandleGetXmpStatus();
    });

    // POST /api/xmp/property - Get a specific XMP property by namespace URI and property name. Uses POST because GET with body is non-standard. Requires XMP Toolkit SDK.
    HttpServer::Post("/api/xmp/property", [](const std::string& body) {
        return HandleGetXmpProperty(body);
    });

    // POST /api/xmp/property/set - Set a specific XMP property value. Requires XMP Toolkit SDK for property-level access.
    HttpServer::Post("/api/xmp/property/set", [](const std::string& body) {
        return HandleSetXmpProperty(body);
    });

    // POST /api/xmp/namespace - Register a custom XMP namespace with a suggested prefix. The actual prefix may differ if already registered. Requires XMP Toolkit SDK.
    HttpServer::Post("/api/xmp/namespace", [](const std::string& body) {
        return HandleRegisterXmpNamespace(body);
    });

    // GET /api/doc/info - Aggregated document info: name (no extension), directory path, saved state, artboard dimensions in points and inches.
    HttpServer::Get("/api/doc/info", [](const std::string&) {
        return HandleGetDocumentInfo();
    });

    // GET /api/view/zoom - Get current view zoom level as percentage.
    HttpServer::Get("/api/view/zoom", [](const std::string&) {
        return HandleGetViewZoom();
    });

    // POST /api/view/zoom - Set view zoom level.
    HttpServer::Post("/api/view/zoom", [](const std::string& body) {
        return HandleSetViewZoom(body);
    });

    // POST /api/view/center - Center the view on a point in artwork coordinates.
    HttpServer::Post("/api/view/center", [](const std::string& body) {
        return HandleSetViewCenter(body);
    });

    // POST /api/view/fit-artboard - Zoom to fit the active artboard in the view.
    HttpServer::Post("/api/view/fit-artboard", [](const std::string&) {
        return HandleFitArtboardInView();
    });

    // POST /api/view/fit-selection - Zoom to fit the current selection in the view.
    HttpServer::Post("/api/view/fit-selection", [](const std::string&) {
        return HandleFitSelectionInView();
    });

    // GET /api/query/path-items - Get all path items with bounds, fill, stroke info.
    HttpServer::Get("/api/query/path-items", [](const std::string&) {
        return HandleQueryPathItems();
    });

    // POST /api/query/count - Count art items on a specific layer.
    HttpServer::Post("/api/query/count", [](const std::string& body) {
        return HandleCountItemsOnLayer(body);
    });
}
