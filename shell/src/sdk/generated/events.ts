/**
 * SSE Event Types and Client
 * Auto-generated by NUXP Codegen - DO NOT EDIT
 */

import { getApiUrl, sdkConfig } from '../config';

// ============================================================================
// Event Payload Types
// ============================================================================

/** Fired when the document selection changes */
export interface SelectionEvent {
  /** Number of selected items */
  count: number;
  /** Array of art handle IDs */
  selectedIds: number[];
}

/** Fired on document lifecycle events (open, close, switch) */
export interface DocumentEvent {
  /** Event type */
  type: 'opened' | 'closed' | 'activated';
  /** Name of the document */
  documentName: string;
}

/** Fired when layers are added, removed, or reordered */
export interface LayersEvent {
  /** Current number of layers */
  layerCount: number;
}

/** Fired when art objects are modified */
export interface ArtChangedEvent {
  /** IDs of changed art objects */
  artIds: number[];
  /** Type of change */
  changeType: 'created' | 'modified' | 'deleted';
}

/** Sent on initial connection with plugin version info */
export interface VersionEvent {
  /** Plugin version string */
  version: string;
  /** Build timestamp */
  build: string;
}

// ============================================================================
// Event Type Union and Map
// ============================================================================

/** All possible event names */
export type EventName = 'selection' | 'document' | 'layers' | 'artChanged' | 'version';

/** Maps event names to their payload types */
export interface EventPayloadMap {
  selection: SelectionEvent;
  document: DocumentEvent;
  layers: LayersEvent;
  artChanged: ArtChangedEvent;
  version: VersionEvent;
}

/** Callback type for a specific event */
export type EventCallback<T extends EventName> = (data: EventPayloadMap[T]) => void;

/** Wildcard callback receives event name and data */
export type WildcardCallback = (event: { type: EventName; data: EventPayloadMap[EventName] }) => void;

// ============================================================================
// SSE Client Class
// ============================================================================

const RECONNECT_BASE_DELAY = 3000;
const MAX_RECONNECT_ATTEMPTS = 10;

/**
 * Server-Sent Events client for receiving plugin events.
 * Uses native EventSource with automatic reconnection.
 */
class SSEClient {
  private eventSource: EventSource | null = null;
  private listeners: Map<string, Set<Function>> = new Map();
  private reconnectAttempts = 0;
  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;
  private manuallyDisconnected = false;

  /**
   * Connect to the SSE endpoint
   */
  connect(): void {
    if (this.eventSource || sdkConfig.useMock) {
      return;
    }

    this.manuallyDisconnected = false;
    const url = getApiUrl('/events/stream');

    try {
      this.eventSource = new EventSource(url);

      this.eventSource.onopen = () => {
        console.log('[SSE] Connected');
        this.reconnectAttempts = 0;
      };

      this.eventSource.onerror = () => {
        console.error('[SSE] Connection error');
        this.handleDisconnect();
      };

      // Register handlers for each event type
      this.registerHandler('selection');
      this.registerHandler('document');
      this.registerHandler('layers');
      this.registerHandler('artChanged');
      this.registerHandler('version');
    } catch (error) {
      console.error('[SSE] Failed to create EventSource:', error);
      this.handleDisconnect();
    }
  }

  /**
   * Disconnect from the SSE endpoint
   */
  disconnect(): void {
    this.manuallyDisconnected = true;

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }

    this.reconnectAttempts = 0;
  }

  /**
   * Subscribe to a specific event type
   */
  on<T extends EventName>(event: T, callback: EventCallback<T>): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(callback);

    return () => this.off(event, callback);
  }

  /**
   * Subscribe to all events
   */
  onAll(callback: WildcardCallback): () => void {
    if (!this.listeners.has('*')) {
      this.listeners.set('*', new Set());
    }
    this.listeners.get('*')!.add(callback);

    return () => {
      this.listeners.get('*')?.delete(callback);
    };
  }

  /**
   * Unsubscribe from an event
   */
  off<T extends EventName>(event: T, callback: EventCallback<T>): void {
    this.listeners.get(event)?.delete(callback);
  }

  /**
   * Check if connected
   */
  get isConnected(): boolean {
    return this.eventSource?.readyState === EventSource.OPEN;
  }

  private registerHandler(eventType: EventName): void {
    if (!this.eventSource) return;

    this.eventSource.addEventListener(eventType, (event: MessageEvent) => {
      try {
        const data = JSON.parse(event.data);
        this.dispatch(eventType, data);
      } catch (error) {
        console.error(`[SSE] Error parsing ${eventType} event:`, error);
      }
    });
  }

  private dispatch(eventType: EventName, data: EventPayloadMap[EventName]): void {
    // Call specific listeners
    this.listeners.get(eventType)?.forEach((cb) => {
      try {
        cb(data);
      } catch (error) {
        console.error(`[SSE] Error in ${eventType} listener:`, error);
      }
    });

    // Call wildcard listeners
    this.listeners.get('*')?.forEach((cb) => {
      try {
        (cb as WildcardCallback)({ type: eventType, data });
      } catch (error) {
        console.error('[SSE] Error in wildcard listener:', error);
      }
    });
  }

  private handleDisconnect(): void {
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }

    if (this.manuallyDisconnected) {
      return;
    }

    if (this.reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
      this.reconnectAttempts++;
      const delay = RECONNECT_BASE_DELAY * Math.min(this.reconnectAttempts, 5);

      console.log(`[SSE] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);

      this.reconnectTimer = setTimeout(() => {
        this.reconnectTimer = null;
        this.connect();
      }, delay);
    } else {
      console.error('[SSE] Max reconnect attempts reached');
    }
  }
}

// ============================================================================
// Singleton Instance and Exports
// ============================================================================

/** Global SSE client instance */
export const sseClient = new SSEClient();

/** Connect to SSE endpoint */
export const connectSSE = () => sseClient.connect();

/** Disconnect from SSE endpoint */
export const disconnectSSE = () => sseClient.disconnect();

/** Subscribe to a specific event */
export const onEvent = <T extends EventName>(event: T, callback: EventCallback<T>) =>
  sseClient.on(event, callback);

/** Subscribe to all events */
export const onAllEvents = (callback: WildcardCallback) => sseClient.onAll(callback);
