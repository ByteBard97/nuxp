/**
 * Custom Route Client
 * Auto-generated by NUXP Codegen - DO NOT EDIT
 */

import { getApiUrl } from '../config';

// ============================================================================
// Request/Response Types
// ============================================================================

/** GET /api/selection - Get all currently selected art objects as handle IDs. Wraps AIMatchingArtSuite::GetSelectedArt (AIArtHandle*** output). Handler must iterate, register each handle, and free with MdMemoryDisposeHandle. */
export interface GetSelectionResponse {
  /** Array of art handle IDs registered with HandleManager::art */
  handles: number[];
  /** Number of selected objects */
  count: number;
}

/** POST /api/selection/match - Get art objects matching type and attribute filters. Wraps AIMatchingArtSuite::GetMatchingArt with AIMatchingArtSpec. */
export interface GetMatchingArtRequest {
  /** AIArtType enum: 0=unknown, 1=group, 2=path, 3=compoundPath, 7=placed, 9=raster, 10=plugin, 11=mesh, 12=textFrame, 13=symbol, -1=any */
  type: number;
  /** Which attribute to filter on (bitmask). 0 means no attribute filter. */
  whichAttr?: number;
  /** Attribute value to match. 0 = NOT set, nonzero = set. */
  attr?: number;
}

export interface GetMatchingArtResponse {
  /** Array of matching art handle IDs */
  handles: number[];
  /** Number of matching objects */
  count: number;
}

/** GET /api/art/{id}/style - Get fill and stroke style of an art object. Wraps AIPathStyleSuite::GetPathStyle. Color is a tagged union — check color.kind to determine which fields are present (gray/rgb/cmyk/pattern/gradient/custom/none). */
export interface GetPathStyleResponse {
  /** Whether the object has a fill */
  fillPaint: boolean;
  /** Whether the object has a stroke */
  strokePaint: boolean;
  /** { color: { kind: string, ...variant fields }, overprint: boolean } */
  fill: Record<string, unknown>;
  /** { color: { kind: string, ... }, overprint: boolean, width: number, cap: number, join: number, miterLimit: number, dash: { length: number, offset: number, array: number[] } } */
  stroke: Record<string, unknown>;
  /** Even-odd fill rule (vs non-zero winding) */
  evenodd: boolean;
  /** Path output resolution (default 800.0) */
  resolution: number;
}

/** POST /api/art/{id}/style - Set fill and stroke style for an art object. Wraps AIPathStyleSuite::SetPathStyle. All fields optional — only provided fields are changed. For color, include kind + variant fields. */
export interface SetPathStyleRequest {
  /** Whether to fill */
  fillPaint?: boolean;
  /** Whether to stroke */
  strokePaint?: boolean;
  /** { color: { kind, ...variant }, overprint?: boolean } */
  fill?: Record<string, unknown>;
  /** { color?: { kind, ... }, overprint?: boolean, width?: number, cap?: number, join?: number, miterLimit?: number, dash?: { length, offset, array } } */
  stroke?: Record<string, unknown>;
  /** Even-odd fill rule */
  evenodd?: boolean;
}

export interface SetPathStyleResponse {
  /** Whether the style was applied */
  success: boolean;
}

/** GET /api/art/{id}/segments - Get all path segments for a path art object. Wraps AIPathSuite::GetPathSegmentCount + GetPathSegments. Each segment has anchor (p), incoming handle (in), outgoing handle (out), and corner flag. */
export interface GetPathSegmentsResponse {
  /** Number of segments */
  count: number;
  /** Whether the path is closed */
  closed: boolean;
  /** Array of { p: {h,v}, in: {h,v}, out: {h,v}, corner: boolean } */
  segments: Record<string, unknown>;
}

/** POST /api/art/{id}/segments - Set path segments for a path art object. Wraps AIPathSuite::SetPathSegments. Replaces segments starting at given index. */
export interface SetPathSegmentsRequest {
  /** Starting segment index (0-based) */
  startIndex?: number;
  /** Array of { p: {h,v}, in: {h,v}, out: {h,v}, corner: boolean } */
  segments: Record<string, unknown>;
  /** Set path closed/open state */
  closed?: boolean;
}

export interface SetPathSegmentsResponse {
  /** Whether segments were set */
  success: boolean;
}

/** POST /api/artboard/check-bounds - Check if a rectangle fits within the active artboard bounds and compute clamped coordinates. Uses AIArtboardSuite to get artboard geometry and GeometryUtils for intersection. */
export interface CheckBoundsRequest {
  /** X coordinate of the rectangle origin */
  x: number;
  /** Y coordinate of the rectangle origin */
  y: number;
  /** Width of the rectangle */
  width: number;
  /** Height of the rectangle */
  height: number;
}

export interface CheckBoundsResponse {
  /** Whether the rectangle fits entirely within the artboard */
  fits: boolean;
  /** X coordinate clamped to artboard bounds */
  clampedX: number;
  /** Y coordinate clamped to artboard bounds */
  clampedY: number;
}

/** POST /api/selection/deselect-all - Deselect all currently selected art objects. Wraps AIMatchingArtSuite iteration + AIArtSuite::SetArtUserAttr to clear kArtSelected flag. */
export interface DeselectAllResponse {
  /** Whether deselection completed successfully */
  success: boolean;
}

/** POST /api/selection/select - Select art objects by their handle IDs. Resolves handles from HandleManager::art, then sets kArtSelected attribute via AIArtSuite::SetArtUserAttr. */
export interface SelectByHandlesRequest {
  /** Array of art handle IDs to select */
  handles: number[];
}

export interface SelectByHandlesResponse {
  /** Number of objects successfully selected */
  selected: number;
}

/** GET /api/query/text-frames - Query all text frame art objects in the current document. Wraps AIMatchingArtSuite::GetMatchingArt with type=kTextFrameArt. Returns handles and basic properties for each frame. */
export interface QueryTextFramesResponse {
  /** Array of { handle: number, name: string, bounds: {left,top,right,bottom} } */
  frames: Record<string, unknown>;
  /** Number of text frames found */
  count: number;
}

/** GET /api/query/layers - Query all layers in the current document with their properties. Wraps AILayerSuite iteration (CountLayers + GetNthLayer + layer property getters). */
export interface QueryLayersResponse {
  /** Array of { handle: number, title: string, visible: boolean, editable: boolean, printed: boolean } */
  layers: Record<string, unknown>;
  /** Number of layers */
  count: number;
}

/** POST /api/query/find - Find art objects by name. Iterates document art tree using AIArtSuite::GetArtFirstChild/GetArtSibling, checking GetArtName against the query string. */
export interface FindArtByNameRequest {
  /** Name to search for (case-sensitive substring match) */
  name: string;
}

export interface FindArtByNameResponse {
  /** Array of { handle: number, name: string, type: number, bounds: {left,top,right,bottom} } */
  items: Record<string, unknown>;
  /** Number of matching items */
  count: number;
}

/** GET /api/art/{id}/area - Calculate the area of a path art object using the shoelace formula on linearized bezier segments. Uses GeometryUtils::CalculatePathArea. */
export interface CalculatePathAreaResponse {
  /** Absolute area in square points (always positive) */
  area: number;
  /** Signed area (positive for CCW, negative for CW winding) */
  signed_area: number;
}

/** POST /api/text/create - Create a new point text frame. Uses AITextFrameSuite::NewPointText via ATEBridge (isolated ATE compilation unit). */
export interface CreateTextFrameRequest {
  /** Anchor point X coordinate in points */
  x: number;
  /** Anchor point Y coordinate in points (Illustrator coordinates) */
  y: number;
  /** 0 = horizontal (default), 1 = vertical */
  orientation?: number;
  /** Initial text content (requires ATE bridge) */
  contents?: string;
}

export interface CreateTextFrameResponse {
  /** Whether the text frame was created */
  success: boolean;
  /** Handle ID registered with HandleManager::art */
  artId: number;
}

/** GET /api/text/{id}/content - Get text content from a text frame via ATE TextRangeRef. */
export interface GetTextContentResponse {
  /** Whether content was retrieved */
  success: boolean;
  /** The art handle ID */
  artId: number;
  /** Text content of the frame */
  contents: string;
}

/** POST /api/text/{id}/content - Set text content on a text frame. Replaces all existing text. */
export interface SetTextContentRequest {
  /** New text content to set */
  contents: string;
}

export interface SetTextContentResponse {
  /** Whether content was set */
  success: boolean;
  /** The art handle ID */
  artId: number;
}

/** GET /api/xmp - Get full document XMP metadata as an XML packet string. Uses AIDocumentSuite to retrieve the XMP metadata. */
export interface GetDocumentXmpResponse {
  /** Whether retrieval succeeded */
  success: boolean;
  /** XMP metadata XML packet (null if no metadata) */
  xmp: string;
}

/** POST /api/xmp - Set full document XMP metadata from an XML packet string. Pass xmp as null to clear metadata. */
export interface SetDocumentXmpRequest {
  /** XMP metadata XML packet string, or null to clear */
  xmp: string;
}

export interface SetDocumentXmpResponse {
  /** Whether the metadata was set */
  success: boolean;
  /** Status message */
  message: string;
}

/** GET /api/xmp/status - Check XMP availability and capabilities. Reports whether document-level and property-level XMP access is available. */
export interface GetXmpStatusResponse {
  /** Whether status check succeeded */
  success: boolean;
  /** Whether XMP is available (AIDocument suite acquired) */
  available: boolean;
  /** Whether property-level XMP access is available (XMP Toolkit) */
  propertyAccess: boolean;
  /** { getDocumentXMP: boolean, setDocumentXMP: boolean, getProperty: boolean, setProperty: boolean, registerNamespace: boolean } */
  capabilities: Record<string, unknown>;
}

/** POST /api/xmp/property - Get a specific XMP property by namespace URI and property name. Uses POST because GET with body is non-standard. Requires XMP Toolkit SDK. */
export interface GetXmpPropertyRequest {
  /** XMP namespace URI */
  namespace: string;
  /** XMP property name */
  name: string;
}

export interface GetXmpPropertyResponse {
  /** Whether property was retrieved */
  success: boolean;
  /** The namespace URI queried */
  namespace: string;
  /** The property name queried */
  name: string;
  /** Property value (null if not found) */
  value: string;
  /** Whether the property exists */
  found: boolean;
}

/** POST /api/xmp/property/set - Set a specific XMP property value. Requires XMP Toolkit SDK for property-level access. */
export interface SetXmpPropertyRequest {
  /** XMP namespace URI */
  namespace: string;
  /** XMP property name */
  name: string;
  /** Value to set */
  value: string;
}

export interface SetXmpPropertyResponse {
  /** Whether the property was set */
  success: boolean;
  /** The namespace URI */
  namespace: string;
  /** The property name */
  name: string;
  /** The value that was set */
  value: string;
}

/** POST /api/xmp/namespace - Register a custom XMP namespace with a suggested prefix. The actual prefix may differ if already registered. Requires XMP Toolkit SDK. */
export interface RegisterXmpNamespaceRequest {
  /** Namespace URI to register */
  uri: string;
  /** Suggested namespace prefix */
  prefix: string;
}

export interface RegisterXmpNamespaceResponse {
  /** Whether registration succeeded */
  success: boolean;
  /** The registered namespace URI */
  uri: string;
  /** The prefix that was requested */
  requestedPrefix: string;
  /** The actual prefix assigned (may differ from requested) */
  actualPrefix: string;
}

/** GET /api/doc/info - Aggregated document info: name (no extension), directory path, saved state, artboard dimensions in points and inches. */
export interface GetDocumentInfoResponse {
  /** Document name without extension */
  name: string;
  /** Directory path */
  path: string;
  /** Full file path including filename */
  fullPath: string;
  /** Whether document has been saved */
  saved: boolean;
  /** Array of artboard info with bounds, widthPoints, heightPoints, widthInches, heightInches */
  artboards: Record<string, unknown>;
}

/** GET /api/view/zoom - Get current view zoom level as percentage. */
export interface GetViewZoomResponse {
  /** Zoom percentage (100 = 100%) */
  zoom: number;
}

/** POST /api/view/zoom - Set view zoom level. */
export interface SetViewZoomRequest {
  /** Zoom percentage (100 = 100%) */
  zoom: number;
}

export interface SetViewZoomResponse {
  success: boolean;
  /** Actual zoom after setting */
  zoom: number;
}

/** POST /api/view/center - Center the view on a point in artwork coordinates. */
export interface SetViewCenterRequest {
  /** X coordinate in points */
  x: number;
  /** Y coordinate in points */
  y: number;
}

export interface SetViewCenterResponse {
  success: boolean;
}

/** POST /api/view/fit-artboard - Zoom to fit the active artboard in the view. */
export interface FitArtboardInViewResponse {
  success: boolean;
}

/** POST /api/view/fit-selection - Zoom to fit the current selection in the view. */
export interface FitSelectionInViewResponse {
  success: boolean;
}

/** GET /api/query/path-items - Get all path items with bounds, fill, stroke info. */
export interface QueryPathItemsResponse {
  /** Array of path item info with handles */
  items: Record<string, unknown>;
  count: number;
}

/** POST /api/query/count - Count art items on a specific layer. */
export interface CountItemsOnLayerRequest {
  /** Layer name */
  layer: string;
}

export interface CountItemsOnLayerResponse {
  count: number;
  layer: string;
}

// ============================================================================
// HTTP Client
// ============================================================================

const DEFAULT_TIMEOUT = 10000;

async function fetchRoute<T>(
  method: string,
  url: string,
  body?: string | null,
  timeoutMs: number = DEFAULT_TIMEOUT
): Promise<T> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const response = await fetch(url, {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: body ?? undefined,
      signal: controller.signal,
    });
    clearTimeout(timeoutId);

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`HTTP ${response.status}: ${text}`);
    }

    const text = await response.text();
    if (!text || text.trim() === '') return {} as T;
    return JSON.parse(text) as T;
  } catch (error) {
    clearTimeout(timeoutId);
    throw error;
  }
}

// ============================================================================
// Route Functions
// ============================================================================

/** GET /api/selection - Get all currently selected art objects as handle IDs. Wraps AIMatchingArtSuite::GetSelectedArt (AIArtHandle*** output). Handler must iterate, register each handle, and free with MdMemoryDisposeHandle. */
export async function GetSelection(): Promise<GetSelectionResponse> {
  return fetchRoute<GetSelectionResponse>('GET', getApiUrl('/api/selection'));
}

/** POST /api/selection/match - Get art objects matching type and attribute filters. Wraps AIMatchingArtSuite::GetMatchingArt with AIMatchingArtSpec. */
export async function GetMatchingArt(params: GetMatchingArtRequest): Promise<GetMatchingArtResponse> {
  return fetchRoute<GetMatchingArtResponse>('POST', getApiUrl('/api/selection/match'), JSON.stringify(params));
}

/** GET /api/art/{id}/style - Get fill and stroke style of an art object. Wraps AIPathStyleSuite::GetPathStyle. Color is a tagged union — check color.kind to determine which fields are present (gray/rgb/cmyk/pattern/gradient/custom/none). */
export async function GetPathStyle(id: string): Promise<GetPathStyleResponse> {
  return fetchRoute<GetPathStyleResponse>('GET', getApiUrl(`/api/art/${encodeURIComponent(id)}/style`));
}

/** POST /api/art/{id}/style - Set fill and stroke style for an art object. Wraps AIPathStyleSuite::SetPathStyle. All fields optional — only provided fields are changed. For color, include kind + variant fields. */
export async function SetPathStyle(id: string, params: SetPathStyleRequest): Promise<SetPathStyleResponse> {
  return fetchRoute<SetPathStyleResponse>('POST', getApiUrl(`/api/art/${encodeURIComponent(id)}/style`), JSON.stringify(params));
}

/** GET /api/art/{id}/segments - Get all path segments for a path art object. Wraps AIPathSuite::GetPathSegmentCount + GetPathSegments. Each segment has anchor (p), incoming handle (in), outgoing handle (out), and corner flag. */
export async function GetPathSegments(id: string): Promise<GetPathSegmentsResponse> {
  return fetchRoute<GetPathSegmentsResponse>('GET', getApiUrl(`/api/art/${encodeURIComponent(id)}/segments`));
}

/** POST /api/art/{id}/segments - Set path segments for a path art object. Wraps AIPathSuite::SetPathSegments. Replaces segments starting at given index. */
export async function SetPathSegments(id: string, params: SetPathSegmentsRequest): Promise<SetPathSegmentsResponse> {
  return fetchRoute<SetPathSegmentsResponse>('POST', getApiUrl(`/api/art/${encodeURIComponent(id)}/segments`), JSON.stringify(params));
}

/** POST /api/artboard/check-bounds - Check if a rectangle fits within the active artboard bounds and compute clamped coordinates. Uses AIArtboardSuite to get artboard geometry and GeometryUtils for intersection. */
export async function CheckBounds(params: CheckBoundsRequest): Promise<CheckBoundsResponse> {
  return fetchRoute<CheckBoundsResponse>('POST', getApiUrl('/api/artboard/check-bounds'), JSON.stringify(params));
}

/** POST /api/selection/deselect-all - Deselect all currently selected art objects. Wraps AIMatchingArtSuite iteration + AIArtSuite::SetArtUserAttr to clear kArtSelected flag. */
export async function DeselectAll(): Promise<DeselectAllResponse> {
  return fetchRoute<DeselectAllResponse>('POST', getApiUrl('/api/selection/deselect-all'));
}

/** POST /api/selection/select - Select art objects by their handle IDs. Resolves handles from HandleManager::art, then sets kArtSelected attribute via AIArtSuite::SetArtUserAttr. */
export async function SelectByHandles(params: SelectByHandlesRequest): Promise<SelectByHandlesResponse> {
  return fetchRoute<SelectByHandlesResponse>('POST', getApiUrl('/api/selection/select'), JSON.stringify(params));
}

/** GET /api/query/text-frames - Query all text frame art objects in the current document. Wraps AIMatchingArtSuite::GetMatchingArt with type=kTextFrameArt. Returns handles and basic properties for each frame. */
export async function QueryTextFrames(): Promise<QueryTextFramesResponse> {
  return fetchRoute<QueryTextFramesResponse>('GET', getApiUrl('/api/query/text-frames'));
}

/** GET /api/query/layers - Query all layers in the current document with their properties. Wraps AILayerSuite iteration (CountLayers + GetNthLayer + layer property getters). */
export async function QueryLayers(): Promise<QueryLayersResponse> {
  return fetchRoute<QueryLayersResponse>('GET', getApiUrl('/api/query/layers'));
}

/** POST /api/query/find - Find art objects by name. Iterates document art tree using AIArtSuite::GetArtFirstChild/GetArtSibling, checking GetArtName against the query string. */
export async function FindArtByName(params: FindArtByNameRequest): Promise<FindArtByNameResponse> {
  return fetchRoute<FindArtByNameResponse>('POST', getApiUrl('/api/query/find'), JSON.stringify(params));
}

/** GET /api/art/{id}/area - Calculate the area of a path art object using the shoelace formula on linearized bezier segments. Uses GeometryUtils::CalculatePathArea. */
export async function CalculatePathArea(id: string): Promise<CalculatePathAreaResponse> {
  return fetchRoute<CalculatePathAreaResponse>('GET', getApiUrl(`/api/art/${encodeURIComponent(id)}/area`));
}

/** POST /api/text/create - Create a new point text frame. Uses AITextFrameSuite::NewPointText via ATEBridge (isolated ATE compilation unit). */
export async function CreateTextFrame(params: CreateTextFrameRequest): Promise<CreateTextFrameResponse> {
  return fetchRoute<CreateTextFrameResponse>('POST', getApiUrl('/api/text/create'), JSON.stringify(params));
}

/** GET /api/text/{id}/content - Get text content from a text frame via ATE TextRangeRef. */
export async function GetTextContent(id: string): Promise<GetTextContentResponse> {
  return fetchRoute<GetTextContentResponse>('GET', getApiUrl(`/api/text/${encodeURIComponent(id)}/content`));
}

/** POST /api/text/{id}/content - Set text content on a text frame. Replaces all existing text. */
export async function SetTextContent(id: string, params: SetTextContentRequest): Promise<SetTextContentResponse> {
  return fetchRoute<SetTextContentResponse>('POST', getApiUrl(`/api/text/${encodeURIComponent(id)}/content`), JSON.stringify(params));
}

/** GET /api/xmp - Get full document XMP metadata as an XML packet string. Uses AIDocumentSuite to retrieve the XMP metadata. */
export async function GetDocumentXmp(): Promise<GetDocumentXmpResponse> {
  return fetchRoute<GetDocumentXmpResponse>('GET', getApiUrl('/api/xmp'));
}

/** POST /api/xmp - Set full document XMP metadata from an XML packet string. Pass xmp as null to clear metadata. */
export async function SetDocumentXmp(params: SetDocumentXmpRequest): Promise<SetDocumentXmpResponse> {
  return fetchRoute<SetDocumentXmpResponse>('POST', getApiUrl('/api/xmp'), JSON.stringify(params));
}

/** GET /api/xmp/status - Check XMP availability and capabilities. Reports whether document-level and property-level XMP access is available. */
export async function GetXmpStatus(): Promise<GetXmpStatusResponse> {
  return fetchRoute<GetXmpStatusResponse>('GET', getApiUrl('/api/xmp/status'));
}

/** POST /api/xmp/property - Get a specific XMP property by namespace URI and property name. Uses POST because GET with body is non-standard. Requires XMP Toolkit SDK. */
export async function GetXmpProperty(params: GetXmpPropertyRequest): Promise<GetXmpPropertyResponse> {
  return fetchRoute<GetXmpPropertyResponse>('POST', getApiUrl('/api/xmp/property'), JSON.stringify(params));
}

/** POST /api/xmp/property/set - Set a specific XMP property value. Requires XMP Toolkit SDK for property-level access. */
export async function SetXmpProperty(params: SetXmpPropertyRequest): Promise<SetXmpPropertyResponse> {
  return fetchRoute<SetXmpPropertyResponse>('POST', getApiUrl('/api/xmp/property/set'), JSON.stringify(params));
}

/** POST /api/xmp/namespace - Register a custom XMP namespace with a suggested prefix. The actual prefix may differ if already registered. Requires XMP Toolkit SDK. */
export async function RegisterXmpNamespace(params: RegisterXmpNamespaceRequest): Promise<RegisterXmpNamespaceResponse> {
  return fetchRoute<RegisterXmpNamespaceResponse>('POST', getApiUrl('/api/xmp/namespace'), JSON.stringify(params));
}

/** GET /api/doc/info - Aggregated document info: name (no extension), directory path, saved state, artboard dimensions in points and inches. */
export async function GetDocumentInfo(): Promise<GetDocumentInfoResponse> {
  return fetchRoute<GetDocumentInfoResponse>('GET', getApiUrl('/api/doc/info'));
}

/** GET /api/view/zoom - Get current view zoom level as percentage. */
export async function GetViewZoom(): Promise<GetViewZoomResponse> {
  return fetchRoute<GetViewZoomResponse>('GET', getApiUrl('/api/view/zoom'));
}

/** POST /api/view/zoom - Set view zoom level. */
export async function SetViewZoom(params: SetViewZoomRequest): Promise<SetViewZoomResponse> {
  return fetchRoute<SetViewZoomResponse>('POST', getApiUrl('/api/view/zoom'), JSON.stringify(params));
}

/** POST /api/view/center - Center the view on a point in artwork coordinates. */
export async function SetViewCenter(params: SetViewCenterRequest): Promise<SetViewCenterResponse> {
  return fetchRoute<SetViewCenterResponse>('POST', getApiUrl('/api/view/center'), JSON.stringify(params));
}

/** POST /api/view/fit-artboard - Zoom to fit the active artboard in the view. */
export async function FitArtboardInView(): Promise<FitArtboardInViewResponse> {
  return fetchRoute<FitArtboardInViewResponse>('POST', getApiUrl('/api/view/fit-artboard'));
}

/** POST /api/view/fit-selection - Zoom to fit the current selection in the view. */
export async function FitSelectionInView(): Promise<FitSelectionInViewResponse> {
  return fetchRoute<FitSelectionInViewResponse>('POST', getApiUrl('/api/view/fit-selection'));
}

/** GET /api/query/path-items - Get all path items with bounds, fill, stroke info. */
export async function QueryPathItems(): Promise<QueryPathItemsResponse> {
  return fetchRoute<QueryPathItemsResponse>('GET', getApiUrl('/api/query/path-items'));
}

/** POST /api/query/count - Count art items on a specific layer. */
export async function CountItemsOnLayer(params: CountItemsOnLayerRequest): Promise<CountItemsOnLayerResponse> {
  return fetchRoute<CountItemsOnLayerResponse>('POST', getApiUrl('/api/query/count'), JSON.stringify(params));
}
